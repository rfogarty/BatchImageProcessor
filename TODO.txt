Future TODOs
===============
General
DONE * Should have conversion functions between image and pixel types.
** For converting between image types, there are really 3 things to consider:
   1) Channel bitdepth or resolution
   2) Color, grayscale, or other format (HSI/HSL/HSV, CMYK, etc.)
   3) Actual image format, which is really a separate issue and should be resolved in the writing functions
DONE * Test with AddressSanitizer to ensure absolutely no bad memory accesses
DONE * Test with Valgrind to ensure no memory leaks or bad array indexing - see results below.
* Create Parametric Pixel type (records position, x,y) - can be used for complex mask, e.g.


HW#3

Edge Detection [5 points]
* Add edge detection for grey level images to your choice of options.
DONE * Use Sobel operator (3x3) and (5x5) to compute dx and dy, compute gradient amplitude, compute edge direction
* Your program should
DONE ** operate within specified ROIs (up to three ROIs as in previous assignments)
DONE ** generate display of the amplitude of the gradient operator as intensity image
DONE ** generate binary edge image derived from amplitude of the gradient operator by thresholding.
DONE ** generate binary edge image by further thresholding the above output using direction information,
        e.g. display only horizontal (0 degrees +/- 10 degree) or (45 degrees +/- 10 degree) edges etc.
* Utilization of OpenCV [5 points]
 ** replicate first part of this assignment (Sobel) using OpenCV calls and compare performance
DONE ** utilize Canny module of OpenCV and compare to Sobel results
DONE ** implement histogram equalization using OpenCV and compare to your histogram stretching implementation
DONE ** implement Otsu algorithm using OpenCV and compare to your implementation of fixed thresholding.
 ** Combine operations by applying histogram equalization only to foreground as determined by Otsu.
* Advanced Operations [2 points â€“ extra credit]
 ** Implement QR code detection and decoding (see TA instructions)
 ** Get some QR images using your cell camera under varying light conditions and test your implementation.
 ** Process your images using histogram equalization prior QR reading, does it help, describe the results


HW#2

1. Histogram modification [5 points]

DONE  * Add histogram stretching for grey level images to your choice of options
DONE  * Stretching is defined by user provided intensity range parameters (a, b): stretch the intensities in the range between
     a and b on the input image to the range of 0 to 255 as output. [0,a] -> 0, [a,b] -> [0,255], [b,255] -> 255
DONE    ** Your program should apply the procedure within ROI (up to three ROI as Hw1)
DONE    ** Generate image of the histograms for the ROI before and after the procedure, this is good for debugging
       and illustrations
DONE  * Test your program on some grey level images.

2.Color Processing [5 points]

  * operate within specified ROIs (up to three ROIs)
DONE  * Apply the histogram stretching to R,G,B components independently, then combine in one color image,
    experiment and discuss results
DONE  * Implement RGB to HSI conversion
DONE  * Apply intensity histogram stretching by applying it to the I-component, display I as grey level image, then
    convert back to RGB for display. Compare utilization of RGB vs HSI for histogram stretching.
DONE  * [extra credit - 1 point] Perform histogram stretching on both I and S components. How about including all three
    I, S and H components? Experiment.


HW#1

1. General modification
DONE   a. You are to add all new processing to the image manipulation program provided by TA.
DONE   b. Alternatively, you can implement the above by yourself
DONE   c. Modify updated access to parameter file containing list of images, specification of the function to perform 
      on each image, and set of parameters for each image. [1 point]

2. Processing of Grey Level Images
DONE   a. Implement rectangular region of interest (ROI) selection by specifying pixel location (X,Y) of the left-top pixel
      of ROI and ROI size (Sx,Sy). Each of the following operations should be performed in ROI and combined
      image generated. Allow at least three ROIs per image. [1 points]
DONE   b. Modify all HW0 functions (except scaling) to operate only within specified ROIs. Allow different parameters
      for each ROI. [1 points]
DONE   c. Implement uniform smoothing filter operation using square odd window size (WS). Implement adaptive
      processing when smoothing window is close to the ROI boundary by progressively reducing window size all
      the way to 3x3 [3 points]

3. Processing of Color Images
DONE   a. Add color brightness modification to your toolbox. Let value Add-C be user defined threshold. Process each
      color channel: R1=R+Add-C, G1=G+Add-C, B1=B+Add-C. Make sure (R1,G1,B1) are within allowable
      values. This function should operate within specified ROI with different parameters for each ROI. [1 points]
DONE   b. Add color binarization option to your image processing toolbox. Let threshold TC be user defined input
      parameter. For color images, consider TC be a distance from user defined color C(CR,CB,CG) in RGB space.
      Set all pixels within TC distance to "red" and the rest to "white". This function should operate within specified
      ROI with different parameters for each ROI. [3 points]


# Valgrind results (git revision hash: d48eaec8015d75f57e0971d61d07f26cf34046a2)
/home/rfogarty/Documents/USF/ImageProcessing/BatchImageProcessor/project/bin/iptool
Running: time iptool parameters.txt
==146579== Memcheck, a memory error detector
==146579== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==146579== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info
==146579== Command: iptool parameters.txt
==146579== 
==146579== 
==146579== HEAP SUMMARY:
==146579==     in use at exit: 0 bytes in 0 blocks
==146579==   total heap usage: 252 allocs, 252 frees, 83,752,794 bytes allocated
==146579== 
==146579== All heap blocks were freed -- no leaks are possible
==146579== 
==146579== For lists of detected and suppressed errors, rerun with: -s
==146579== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

